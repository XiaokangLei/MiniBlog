{"_id":"0a4ec1f962c046ca0e0b241119e8384c","abstract":"一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内，找出数组中任意一个重复的数字。","classify":"算法基础","content":"## 题目链接\n\n\n[牛客网](https://www.nowcoder.com/practice/6fe361ede7e54db1b84adc81d09d8524?tpId=13)\n\n## 题目描述\n\n在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组[2,3,1,0,2,5,3]，那么对应的输出是2或者3。存在不合法的输入的话输出-1。\n\n**数据范围**：0 ≤ n ≤ 10000\n**进阶**：时间复杂度 O(n) ，空间复杂度 O(n)\n\n```html\nInput:\n{2, 3, 1, 0, 2, 5}\n\nOutput:\n2\n```\n\n## 解题思路\n\n要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。\n\n对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。\n\n以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：\n\n<div align=\"center\"> <img src=\"https://6669-final-6gypsolb231307a9-1304273986.tcb.qcloud.la/%E5%89%91%E6%8C%87Offer/0001.gif\" width=\"350px\"> </div><br>\n\n### 解题步骤\n\n- step 1：遍历数组，遇到数组元素与下标相同的不用管。\n- step 2：遇到数组元素与下标不同，就将其交换到属于它的位置，交换前检查那个位置是否有相同的元素，若有则重复。\n- step 3：遍历结束完全交换也没重复，则返回-1.\n\n### 示例代码\n\n- Java/C++/Python示例代码\n\n#### Java代码\n\n```java\nimport java.util.*;\npublic class Solution {\n    //交换函数\n    private void swap(int[] numbers, int a, int b){\n        int temp = numbers[a];\n        numbers[a] = numbers[b];\n        numbers[b] = temp;\n    }\n    public int duplicate (int[] numbers) {\n        for(int i = 0; i < numbers.length; i++){\n            //该位置本来就是对的\n            if(numbers[i] == i)\n                continue;\n            //位置不对，需要换到自己对应的位置\n            else{\n                //对应位置相等，重复\n                if(numbers[i] == numbers[numbers[i]])\n                    return numbers[i];\n                //交换位置\n                else\n                    swap(numbers, i, numbers[i]);\n            }\n        }\n        //没有重复\n        return -1;\n    }\n}\n```\n\n#### C++代码\n\n```c++\nclass Solution {\npublic:\n    int duplicate(vector<int>& numbers) {\n        for(int i = 0; i < numbers.size(); i++){\n            //该位置本来就是对的\n            if(numbers[i] == i)\n                continue;\n            //位置不对，需要换到自己对应的位置\n            else{\n                //对应位置相等，重复\n                if(numbers[i] == numbers[numbers[i]])\n                    return numbers[i];\n                //交换位置\n                else\n                    swap(numbers[i], numbers[numbers[i]]);\n            }\n        }\n        //没有重复\n        return -1;\n    }\n};\n```\n\n#### Python代码\n\n```python\nclass Solution:\n    #交换函数\n    def swap(self, numbers: List[int], a: int, b: int):\n        temp = numbers[a]\n        numbers[a] = numbers[b]\n        numbers[b] = temp\n    \n    def duplicate(self , numbers: List[int]) -> int:\n        for i in range(len(numbers)):\n            #该位置本来就是对的\n            if numbers[i] == i:\n                continue\n            #位置不对，需要换到自己对应的位置\n            else:\n                #对应位置相等，重复\n                if numbers[i] == numbers[numbers[i]]:\n                    return numbers[i]\n                #交换位置\n                else:\n                    self.swap(numbers, i, numbers[i])\n        #没有重复\n        return -1\n```\n\n\n","isShow":1,"title":"数组中重复的数字","totalCollection":3,"totalComments":0.0,"totalVisits":88.0,"totalZans":2,"_createTime":1656768202249,"_updateTime":1657942631879,"defaultImageUrl":"https://6669-final-6gypsolb231307a9-1304273986.tcb.qcloud.la/%E5%89%91%E6%8C%87Offer/Offer_light.jpg?sign=9c78f95f602d8de1e2260c93b631ea2e&t=1656768535","qrCode":"cloud://final-6gypsolb231307a9.6669-final-6gypsolb231307a9-1304273986/0a4ec1f962c046ca0e0b241119e8384c.png","resourceId":"6842667962d0293308fc7ec405f594f0","label":["数组与矩阵",""],"kind":["剑指Offer"]}
{"_id":"0ab5303b62c30cea0cc1bbd52f480208","abstract":"一个二维数组array中每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。判断数组中是否含有某整数。","classify":"剑指Offer","content":"\n## 题目描述\n\n在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n**数据范围**：矩阵的长宽满足 0 ≤ n, m ≤ 500，矩阵中的值满足 0 ≤ val ≤ 10^9\n\n**进阶**：空间复杂度 O(1)，时间复杂度 O(n+m)\n\n```html\nConsider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\nGiven target = 5, return true.\nGiven target = 20, return false.\n```\n\n## 解题思路\n\n要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。\n\n该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。\n\n<div align=\"center\"> <img src=\"https://6669-final-6gypsolb231307a9-1304273986.tcb.qcloud.la/%E5%89%91%E6%8C%87Offer/0002.gif?sign=c5a6fa102d5d5302c36faf9bf565fb63&t=1656949963\" width=\"400px\"> </div><br>\n\n### 解题步骤\n\n- step 1：首先获取矩阵的两个边长，判断特殊情况。\n- step 2：首先以右上角为起点，若是它小于目标元素，则往左移动去找小的，若是他大于目标元素，则往下移动去找大的。\n- step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。\n\n### 示例代码\n\n- Java/C++/Python示例代码\n\n#### Java代码\n\n```java\npublic boolean Find(int target, int[][] matrix) {\n    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)\n        return false;\n    int rows = matrix.length, cols = matrix[0].length;\n    int r = 0, c = cols - 1; // 从右上角开始\n    while (r <= rows - 1 && c >= 0) {\n        if (target == matrix[r][c])\n            return true;\n        else if (target > matrix[r][c])\n            r++;\n        else\n            c--;\n    }\n    return false;\n}\n```\n\n#### C++代码(从左下到右上)\n\n```c++\nclass Solution {\npublic:\n    bool Find(int target, vector<vector<int> > array) {\n        //优先判断特殊\n        if(array.size() == 0)  \n            return false;\n        int n = array.size();\n        if(array[0].size() == 0)  \n            return false;\n        int m = array[0].size();\n        //从最左下角的元素开始往左或往上\n        for(int i = n - 1, j = 0; i >= 0 && j < m; ){ \n            //元素较大，往上走\n            if(array[i][j] > target)   \n                i--;\n            //元素较小，往右走\n            else if(array[i][j] < target) \n                j++;\n            else\n                return true;\n        }\n        return false;\n    }\n};\n```\n\n#### Python代码(从左下到右上)\n\n```python\nclass Solution:\n    def Find(self , target: int, array: List[List[int]]) -> bool:\n        # 优先判断特殊\n        if len(array) == 0: \n            return False\n        n = len(array)\n        if len(array[0]) == 0:\n            return False\n        m = len(array[0])\n        i = n-1\n        j = 0\n        # 从最左下角的元素开始往左或往上\n        while i >=0 and j < m: \n            # 元素较大，往上走\n            if array[i][j] > target: \n                i -= 1\n            # 元素较小，往右走\n            elif array[i][j] < target: \n                j += 1\n            else:\n                return True\n        return False\n```\n\n\n","defaultImageUrl":"https://6669-final-6gypsolb231307a9-1304273986.tcb.qcloud.la/%E5%89%91%E6%8C%87Offer/Offer1.jpg","isShow":1,"title":"二维数组中的查找","totalCollection":2,"totalComments":1,"totalVisits":72.0,"totalZans":6.0,"_createTime":1656949994122,"_updateTime":1657468244948,"qrCode":"cloud://final-6gypsolb231307a9.6669-final-6gypsolb231307a9-1304273986/0ab5303b62c30cea0cc1bbd52f480208.png","label":["基础算法"],"kind":["类别"]}
{"_id":"058dfefe62c30da70bfd9acd08ec10f9","abstract":"实现一个函数，将一个字符串s中的每个空格替换成\"%20\"","classify":"小程序","content":"\n## 题目描述\n\n请实现一个函数，将一个字符串s中的每个空格替换成\"%20\"。\n例如，当字符串为 We Are Happy. 则经过替换之后的字符串为 We%20Are%20Happy.\n\n数据范围: 0 ≤ len(s) ≤ 1000。保证字符串中的字符为大写英文字母、小写英文字母和空格中的一种。\n\n```text\nInput:\n\"A B\"\n\nOutput:\n\"A%20B\"\n```\n\n## 解题思路\n\n① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。\n\n② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。\n\n③ 当 P2 遇到 P1 时（P2 \\<= P1），或者遍历结束（P1 \\< 0），退出。\n\n<div align=\"center\"> <img src=\"./pics/0003.gif\" width=\"350px\"> </div><br>\n\n### 示例代码\n\n- Java/C++/Python示例代码\n\n#### Java代码\n\n```java\npublic String replaceSpace(StringBuffer str) {\n    int P1 = str.length() - 1;\n    for (int i = 0; i <= P1; i++)\n        if (str.charAt(i) == ' ')\n            str.append(\"  \");\n\n    int P2 = str.length() - 1;\n    while (P1 >= 0 && P2 > P1) {\n        char c = str.charAt(P1--);\n        if (c == ' ') {\n            str.setCharAt(P2--, '0');\n            str.setCharAt(P2--, '2');\n            str.setCharAt(P2--, '%');\n        } else {\n            str.setCharAt(P2--, c);\n        }\n    }\n    return str.toString();\n}\n```\n\n我们也可以用下标遍历字符串，每次检查下标所在位置的字符是否为空格，如果不是空格，下标继续往后，如果是空格则调用substr函数将字符串从空格前后截断，然后中间添加\"%20\"后相连即可。\n\n#### C++代码\n\n```c++\nclass Solution {\npublic:\n    string replaceSpace(string s) {\n        string res = \"\";\n        //遍历字符串\n        for(int i = 0; i < s.length(); i++){ \n            //非空格直接复制\n            if(s[i] != ' ') \n                res += s[i];\n            //空格就替换\n            else \n                res += \"%20\"; \n        }\n        return res;\n    }\n};\n```\n\n#### Python代码\n\n```python\nclass Solution:\n    def replaceSpace(self , s: str) -> str:\n        res = \"\"\n        #遍历字符串\n        for i in s:\n            #非空格直接复制\n            if i != ' ': \n                res += i\n            #空格就替换\n            else:\n                res += \"%20\" \n        return res\n```\n\n","defaultImageUrl":"https://6669-final-6gypsolb231307a9-1304273986.tcb.qcloud.la/%E5%89%91%E6%8C%87Offer/Offer1.jpg","isShow":1,"title":"替换空格","totalCollection":2,"totalComments":2.0,"totalVisits":162.0,"totalZans":9.0,"_createTime":1656950183707,"_updateTime":1657468255920,"qrCode":"cloud://final-6gypsolb231307a9.6669-final-6gypsolb231307a9-1304273986/058dfefe62c30da70bfd9acd08ec10f9.png","label":["OCR"],"kind":["技术开发"]}
